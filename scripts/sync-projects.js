import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PROJECTS_MD_PATH = path.join(__dirname, '../projects.md');
const OUTPUT_TS_PATH = path.join(__dirname, '../src/data/projects.ts');

const languageColors = {
    Python: '#3572A5',
    TypeScript: '#2b7489',
    JavaScript: '#F7DF1E',
    'C++': '#f34b7d',
    'Jupyter Notebook': '#DA5B0B',
    Solidity: '#AA6746',
    Rust: '#dea584',
    Go: '#00ADD8',
    Ruby: '#701516',
    HTML: '#e34c26',
    CSS: '#563d7c',
    R: '#198ce7',
    LaTeX: '#3D6117',
};

function parseProjectsMd(content) {
    const lines = content.split('\n');
    const projects = [];
    let currentProject = null;
    let idCounter = 1;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        // Skip empty lines and the header
        if (!line || line === 'Projects') continue;

        // Check for project title line (contains URL)
        // Format: Title — URL
        if (line.includes('— https://')) {
            if (currentProject) {
                projects.push(currentProject);
            }

            const [namePart, urlPart] = line.split('—').map(s => s.trim());
            const github = urlPart;
            // Clean up name (remove trailing spaces or chars if any)
            const name = namePart;

            currentProject = {
                id: idCounter++,
                name: name,
                github: github,
                language: 'Other', // Default
                description: '',
                category: 'all', // Default, will need logic or manual mapping if not in md
                featured: false // Default
            };
        } else if (line.startsWith('Tech:')) {
            if (currentProject) {
                const tech = line.replace('Tech:', '').trim();
                // Use the first tech as the primary language for color mapping
                const primaryTech = tech.split(',')[0].trim();
                currentProject.language = primaryTech;

                // Simple category logic based on tech or keywords
                const lowerTech = tech.toLowerCase();
                if (lowerTech.includes('python') && (lowerTech.includes('agent') || lowerTech.includes('llm'))) {
                    currentProject.category = 'ai-agents';
                } else if (lowerTech.includes('c++') || lowerTech.includes('hpc')) {
                    currentProject.category = 'hpc';
                } else if (lowerTech.includes('trading') || lowerTech.includes('finance')) {
                    currentProject.category = 'trading';
                } else if (lowerTech.includes('research') || lowerTech.includes('jupyter') || lowerTech.includes('ml')) {
                    currentProject.category = 'ml-research';
                } else {
                    currentProject.category = 'tools';
                }
            }
        } else if (line.startsWith('Summary:')) {
            if (currentProject) {
                currentProject.description = line.replace('Summary:', '').trim();

                // Check if featured based on keywords in description or name (optional heuristic)
                // For now, let's keep it simple or use a specific list if user wants
                if (['InvoiceFlowAgent', 'Agentic AI via Hugging Face', 'Mini GPT Engine', 'Python Crypto Trading Engine', 'OrbitAgents', 'DRL4MM'].some(k => currentProject.name.includes(k))) {
                    currentProject.featured = true;
                }
            }
        }
    }

    if (currentProject) {
        projects.push(currentProject);
    }

    return projects;
}

function generateTsContent(projects) {
    const projectsJson = JSON.stringify(projects, null, 4);

    return `// Generated by scripts/sync-projects.js
// Do not edit this file directly. Update projects.md instead.

export const languageColors: Record<string, string> = ${JSON.stringify(languageColors, null, 4)};

export interface Project {
    id: number;
    name: string;
    description: string;
    category: string;
    language: string;
    github: string;
    featured: boolean;
}

export const projects: Project[] = ${projectsJson};

export const categories = [
    { id: 'all', name: 'All Projects' },
    { id: 'ai-agents', name: 'AI & Agents' },
    { id: 'hpc', name: 'High-Performance Computing' },
    { id: 'trading', name: 'Trading & Finance' },
    { id: 'ml-research', name: 'ML Research' },
    { id: 'tools', name: 'Tools & Infrastructure' },
];

export const stats = {
    projects: projects.length,
    languages: new Set(projects.map(p => p.language)).size,
    categories: categories.length - 1,
    experience: new Date().getFullYear() - 2020,
};
`;
}

try {
    const mdContent = fs.readFileSync(PROJECTS_MD_PATH, 'utf8');
    const projects = parseProjectsMd(mdContent);
    const tsContent = generateTsContent(projects);

    fs.writeFileSync(OUTPUT_TS_PATH, tsContent);
    console.log(`Successfully synced ${projects.length} projects to ${OUTPUT_TS_PATH}`);
} catch (error) {
    console.error('Error syncing projects:', error);
    process.exit(1);
}
